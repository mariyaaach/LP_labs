# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Чапалда М.О.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. В Прологе списки представляют собой рекурсивные структуры данных, состоящие из головы (первого элемента) и хвоста (оставшейся части списка). Это отличается от традиционных языков программирования, где списки обычно представлены как линейные массивы или связанные списки.

Списки в Прологе похожи на связанные списки в традиционных языках программирования. Такие списки состоят из элементов, каждый из которых содержит ссылку на следующий элемент списка. Однако, в Прологе списки рекурсивно определены и могут быть пустыми (список без элементов), что отличает их от связанных списков в императивных языках.
## Задание 1.1: Предикат обработки списка

insert_element_custom2(Element, 1, List, [Element|List]). - Предикат для вставки элемента в список на указанную позицию (без использования стандартных предикатов)
insert_element_custom1(Element, Position, List, NewList) :- - Предикат для вставки элемента в список на указанную позицию (с использованием стандартных предикатов)

Примеры использования:
```prolog

?- insert_element_custom2(99, 3, [1,2,3,4,5], NewList).
NewList = [1,2,99,3,4,5].

?- insert_element_custom1(99, 3, [1,2,3,4,5], NewList).
NewList = [1,2,99,3,4,5].

```

Реализация:
```prolog

insert_element_custom2(Element, 1, List, [Element|List]).
insert_element_custom2(Element, Position, [Head|Tail], [Head|NewTail]) :-
    Position > 1,
    NextPosition is Position - 1,
    insert_element_custom2(Element, NextPosition, Tail, NewTail).

insert_element_custom1(Element, Position, List, NewList) :-
    length_custom(List, Length),
    Position > 0,
    Position =< Length + 1,
    append_custom(Prefix, Suffix, List),
    length_custom(Prefix, PositionMinusOne), % Длина префикса
    PositionMinusOne =:= Position - 1,
    append_custom(Prefix, [Element|Suffix], NewList).

```

Данный предикат служит для вставки элемента Element в указанную позицию Position в списке List. Результатом работы предиката будет новый список NewList, в котором элемент Element будет вставлен на указанную позицию.

## Задание 1.2: Предикат обработки числового списка

geometric_progression_custom([X,Y|T]) :- - Предикат для проверки списка на геометрическую прогрессию

Примеры использования:
```prolog

?- geometric_progression_custom([1,2,4,8,16]).
true.

```

Реализация:
```prolog
geometric_progression_custom([]).
geometric_progression_custom([_]).
geometric_progression_custom([X,Y|T]) :-
    Y =:= X * 2,
    geometric_progression_custom([Y|T]).

```

## Задание 2: Реляционное представление данных

Реляционное представление - представление, основанное на отношениях между объектами, такое представление также часто называют табличным. Преимущества реляционного представления в удобном хранении информации, а также в отображении данных в достаточно простой и понятной форме. Недостатками реляционного представления данных заключается в том, что не все предментые области можно представить в виде таблиц, таблицы могут занимать относительно много внешней памяти.

В моем варианте представлений данных о студентах(one.pl) отношения представлены таким образом: student(102,'Петров'). subject('LP','Логическое программирование'). grade('Петровский','LP',5).

Вариант 1

Получить таблицу групп и средний балл по каждой из групп
Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)
Найти количество не сдавших студентов в каждой из групп
1.Получить таблицу групп и средний балл по каждой из групп

Для того, чтобы получить таблицу группы и средний балл по каждой из групп, нужно написать вспомогательные предикаты.

sum([X|Y], S) - вычисление суммы элементов списка. Разделим список на первый элемент и хвост. Рекурсивно ищем сумму элементов списка с конца. Если список пустой, сумма равна 0.

average(X,T) - вычисляет среднее арифметическое значение элементов списка. С помощью предиката length находим длину списка, а предикат sum находит сумму элементов списка. Поделив, находим среднее арифметическое значение элементов списка.

student_average(Student, Res) - вычисление среднего балла студента по всем предметам. С помощью предиката findall ищем оценки студента, а затем при помощи предиката average(X,T) вычисляем среднее арифметическое значение элементов списка оценок студента.

students_average_in_group(Group, R)- получает средний балл ученика в группе.

print_group_average() - получение таблицы групп и средний балл по каждой из групп, а также печать номера группы и среднего балла для каждой группы. С помощью предиката findall создаём список, состоящий из номеров групп. Предикат sort упорядочивают список в соответствии со стандартным порядком и одновременно устраняет повторяющиеся элементы. Далее создаем список, который хранит в себе средние баллы студентов из группы, для этого используем предикат students_average_in_group(Group, R). С помощью average рассчитываем средний балл группы и выводим его.

Реализация:
```prolog

sum([], 0).
sum([X|Y], S) :-
    sum(Y, Q),
    S is Q + X.

average(X, T) :-
    length(X, L),
    sum(X, P),
    T is P / L.

student_average(Student, R) :-
    findall(N, grade(Student, _, N), List),
    average(List, R).

students_average_in_group(Group, R) :-
    student(Group, Student),
    student_average(Student, R).

print_group_average() :-
    findall(Group, student(Group, _), Glist),
    sort(Glist, List),
    member(Group2, List),
    setof(R, students_average_in_group(Group2, R), ListValue),
    average(ListValue, Answer),
    write('Группа №'), write(Group2), write(' средний балл: '), write(Answer), write('\n'), fail.

```
Примеры использования:
```prolog

?- print_group_average().
Группа №101 Средний балл: 3.916666666666667
Группа №102 Средний балл: 3.7291666666666665
Группа №103 Средний балл: 3.6
Группа №104 Средний балл: 3.7916666666666665

```
2.Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)

failed_exam() - предикат, который вычисляет студентов, не сдавших экзамен и печатает их по каждому предмету. С помощью subject(X,lesson) получаем сокращенное название предмета, которое потом нам потребуется для предиката findall. Этот предикат ищет всех студентов, которые не сдали экзамен. С помощью команды write печатаем название предмета и фамилии студентов, не сдавших экзамен по этому предмету.

Реализация:
```prolog

failed_exam() :-
    subject(X, S),
    findall(N, grade(N, X, 2), L),
    write(S), write(' не сдали: '), write(L), write('\n'), fail.

```

Примеры использования:
```prolog

Логическое программирование не сдали: [Запорожцев,Эфиркина,Текстописов]
Математический анализ не сдали: [Запорожцев,Круглосчиталкин,Густобуквенникова,Криптовалютников,Блокчейнис,Азурин]
Функциональное программирование не сдали: [Криптовалютников]
Информатика не сдали: [Эфиркина,Джаво,Безумников]
Английский язык не сдали: [Эфиркина]
Психология не сдали: [Биткоинов,Текстописова,Криптовалютников,Азурин,Вебсервисов]
false.

```
3.Найти количество не сдавших студентов в каждой из групп

Для того, что бы найти количество не сдавших студентов в каждой из групп нужно написать вспомогательные предикаты. failed_student(Name,Group) - находит студентов, которые не сдали экзамен.

failed_in_group(Group,N) - предикат, который по запросу номера группы, вычисляет количество не сдавших студентов в этой группе. С помощью предиката setof создаем список L, который хранит в себе фамилии студентов, не сдавших экзамен. Вычисляем длину этого списка с помощью предиката length

number_failed() - предикат, который находит количество не сдавших студентов в каждой из групп. С помощью предиката findall создаём список, состоящий из номеров групп. Предикат sort упорядочивают список в соответствии со стандартным порядком и одновременно устраняет повторяющиеся элементы. Для каждого значения из списка номеров групп вычисляем количество не сдавших студентов с помощью предиката failed_in_group(Group,N). Выводим номер группы и количество не сдавших студентов в каждой из групп.

Реализация:
```prolog

failed_student(Name,Group) :-
    student(Group,Name),
    grade(Name,_,2).

failed_in_group(Group,N) :-
    setof(X,failed_student(X,Group),L),
    length(L,N).

number_failed():-
    findall(X, student(X, _), Glist),
    sort(Glist, List),
    member(Group, List),
    failed_in_group(Group, N),
    write('Группа: №'), write(Group), write(' не сдали: '), write(N), write('\n'), fail.

```
Примеры использования:
```prolog

?- number_failed().
Группа: №101 не сдали: 2
Группа: №102 не сдали: 4
Группа: №103 не сдали: 3
Группа: №104 не сдали: 4
false.

```
## Выводы

Эта лабораторная работа помогла мне изучить работу со стандартными предикатами для обработки списков в языке программирования Пролог. Я освоила основы языка, разобрался с работой со списками в Пролог, и написала предикаты для обработки чисел в списках. Я также познакомилась с реляционным представлением данных, которое отличается от императивного программирования. В реляционном программировании мы описываем, что представляет собой проблема и какой ожидаемый результат, вместо того чтобы описывать, как решить задачу и получить результат. Я узнала, что в Прологе реляционная база данных представляется в виде набора фактов, что позволяет использовать этот язык как мощный язык запросов для баз данных.



